## 谈谈, Java GC是在什么时候, 对什么东西, 做了什么事情？
地球人都知道, Java有个东西叫垃圾收集器, 它让创建的对象不需要像c/cpp那样delete、free掉, 你能不能谈谈, GC是在什么时候, 对什么东西, 做了什么事情？

**一.回答:什么时候?**
1.**系统空闲的时候**.
    分析:这种回答大约占30%, 遇到的话一般我就会准备转向别的话题, 譬如算法、譬如SSH看看能否发掘一些他擅长的其他方面.
2.**系统自身决定, 不可预测的时间/调用System.gc()的时候.**
    分析:这种回答大约占55%, 大部分应届生都能回答到这个答案, 起码不能算错误是吧, 后续应当细分一下到底是语言表述导致答案太笼统, 还是本身就只有这样一个模糊的认识.
3.**能说出新生代、老年代结构, 能提出minor gc/full gc**
    分析:到了这个层次, 基本上能说对GC运作有概念上的了解, 譬如看过《深入JVM虚拟机》之类的.这部分不足10%.
4.**能说明minor gc/full gc的触发条件、OOM的触发条件, 降低GC的调优的策略**.

> 分析:列举一些我期望的回答:eden满了minor gc, 升到老年代的对象大于老年代剩余空间full gc, 或者小于时被HandlePromotionFailure参数强制full gc；gc与非gc时间耗时超过了GCTimeRatio（GC时间占总时间的比率, 默认值为99, 即允许1%的GC时间, 仅在使用Parallel Scavenge收集器时生效）的限制引发OOM, 调优诸如通过NewRatio控制新生代老年代比例, 通过MaxTenuringThreshold控制进入老年前生存次数等……能回答道这个阶段就会给我带来比较高的期望了, 当然面试的时候正常人都不会记得每个参数的拼写, 我自己写这段话的时候也是翻过手册的.回答道这部分的小于2%.
总结:程序员不能具体控制时间, 系统在不可预测的时间调用System.gc()函数的时候；当然可以通过调优, 用NewRatio控制newObject和oldObject的比例, 用MaxTenuringThreshold 控制进入oldObject的次数, 使得oldObject 存储空间延迟达到full gc,从而使得计时器引发gc时间延迟OOM的时间延迟, 以延长对象生存期.

**二.回答:对什么东西？**
1. 不使用的对象.
    分析:相当于没有回答, 问题就是在问什么对象才是“不使用的对象”.大约占30%.
 2 .超出作用域的对象/引用计数为空的对象.
    分析:这2个回答站了60%, 相当高的比例, 估计学校教java的时候老师就是这样教的.第一个回答没有解决我的疑问, gc到底怎么判断哪些对象在不在作用域的？至于引用计数来判断对象是否可收集的, 我可以会补充一个下面这个例子让面试者分析一下
3. **从gc root开始搜索, 搜索不到的对象.**
    分析:根对象查找、标记已经算是不错了, 小于5%的人可以回答道这步, 估计是引用计数的方式太“深入民心”了.基本可以得到这个问题全部分数.
    PS:有面试者在这个问补充强引用（类似new Object(), 只要强引用还在就不会被回收）、弱引用（还有用但并非必须的对象, 在系统将要发生OOM之前, 才会将这些对象回收）、软引用（只能生存到下一次垃圾收集之前）、幻影引用（无法通过幻影引用得到对象, 和对象的生命周期无关, 唯一目的就是能在这个对象被回收时收到一个系统通知）区别等, 不是我想问的答案, 但可以加分.
4. 从root搜索不到, 而且经过第一次标记、清理后, 仍然没有复活的对象.
    分析:我期待的答案.但是的确很少面试者会回答到这一点, 所以在我心中回答道第3点我就给全部分数. 
>总结:超出了作用域或引用计数为空的对象；从gc root开始搜索找不到的对象, 而且经过一次标记、清理, 仍然没有复活的对象.

**三.回答:做什么？**
1. 删除不使用的对象, 腾出内存空间.
    分析:同问题2第一点.40%.
 2. 补充一些诸如停止其他线程执行、运行finalize等的说明.
    分析:起码把问题具体化了一些, 如果像答案1那样我很难在回答中找到话题继续展开, 大约占40%的人.
3. 能说出诸如新生代做的是复制清理、from survivor、to survivor是干啥用的、老年代做的是标记清理、标记清理后碎片要不要整理、复制清理和标记清理有有什么优劣势等.
    分析:也是看过《深入JVM虚拟机》的基本都能回答道这个程度, 其实到这个程度我已经比较期待了.同样小于10%.
4. 除了3外, 还能讲清楚串行、并行（整理/不整理碎片）、CMS等搜集器可作用的年代、特点、优劣势, 并且能说明控制/调整收集器选择的方式.
分析:同上面2个问题的第四点. 
>总结:删除不使用的对象, 回收内存空间；运行默认的finalize, JVM用from survivor、to survivor对它进行标记清理, 对象序列化后也可以使它复活.