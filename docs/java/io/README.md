---
sidebar: auto
prev: ../se/
next: ../collection/
title: I/O NIO BIO AIO
date: 2019-03-05 15:39
author: dong4j
tags:
- Java
- 面试题
- I/O
---

::: tip Java IO 面试题

:::

<!-- more -->

[[toc]]

[toc]

## IO 与 NIO

**NIO是为了弥补IO操作的不足而诞生的，NIO的一些新特性有：非阻塞I/O，选择器，缓冲以及管道。管道（Channel），缓冲（Buffer） ，选择器（ Selector）是其主要特征**。

**概念解释**

Channel——管道实际上就像传统IO中的流，到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象。一个 Buffer 实质上是一个容器对象。

**每一种基本 Java 类型都有一种缓冲区类型：**

```
ByteBuffer——byte
CharBuffer——char
ShortBuffer——short
IntBuffer——int
LongBuffer——long
FloatBuffer——float
DoubleBuffer——double
```

Selector——选择器用于监听多个管道的事件，使用传统的阻塞IO时我们可以方便的知道什么时候可以进行读写，而使用非阻塞通道，我们需要一些方法来知道什么时候通道准备好了，选择器正是为这个需要而诞生的。

**NIO和传统的IO有什么区别呢？**

**IO是面向流的，NIO是面向块（缓冲区）的。**

IO面向流的操作一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。，导致了数据的读取和写入效率不佳。

NIO面向块的操作在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多，同时数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。通俗来说，NIO采取了“预读”的方式，当你读取某一部分数据时，他就会猜测你下一步可能会读取的数据而预先缓冲下来。

**IO是阻塞的，NIO是非阻塞的**

对于传统的IO，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。

而对于NIO，使用一个线程发送读取数据请求，没有得到响应之前，线程是空闲的，此时线程可以去执行别的任务，而不是像IO中那样只能等待响应完成。

**NIO和IO适用场景**

NIO是为弥补传统IO的不足而诞生的，但是尺有所短寸有所长，NIO也有缺点，因为NIO是面向缓冲区的操作，每一次的数据处理都是对缓冲区进行的，那么就会有一个问题，在数据处理之前必须要判断缓冲区的数据是否完整或者已经读取完毕，如果没有，假设数据只读取了一部分，那么对不完整的数据处理没有任何意义。所以每次数据处理之前都要检测缓冲区数据。

**那么NIO和IO各适用的场景是什么呢？**

如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，这时候用NIO处理数据可能是个很好的选择。

而如果只有少量的连接，而这些连接每次要发送大量的数据，这时候传统的IO更合适。使用哪种处理数据，需要在数据的响应等待时间和检查缓冲区数据的时间上作比较来权衡选择。

**通俗解释，最后，对于NIO和传统IO**

有一个网友讲的生动的例子：

以前的流总是堵塞的，一个线程只要对它进行操作，其它操作就会被堵塞，也就相当于水管没有阀门，你伸手接水的时候，不管水到了没有，你就都只能耗在接水（流）上。

nio的Channel的加入，相当于增加了水龙头（有阀门），虽然一个时刻也只能接一个水管的水，但依赖轮换策略，在水量不大的时候，各个水管里流出来的水，都可以得到妥

善接纳，这个关键之处就是增加了一个接水工，也就是Selector，他负责协调，也就是看哪根水管有水了的话，在当前水管的水接到一定程度的时候，就切换一下：临时关上当

前水龙头，试着打开另一个水龙头（看看有没有水）。

当其他人需要用水的时候，不是直接去接水，而是事前提了一个水桶给接水工，这个水桶就是Buffer。也就是，其他人虽然也可能要等，但不会在现场等，而是回家等，可以做

其它事去，水接满了，接水工会通知他们。

这其实也是非常接近当前社会分工细化的现实，也是统分利用现有资源达到并发效果的一种很经济的手段，而不是动不动就来个并行处理，虽然那样是最简单的，但也是最浪费资源的方式。

# I/O 

66）在我 Java 程序中，我有三个 socket，我需要多少个线程来处理？ 
67）Java 中怎么创建 ByteBuffer？ 
68）Java 中，怎么读写 ByteBuffer ？ 
69）Java 采用的是大端还是小端？ 
70）ByteBuffer 中的字节序是什么？ 
71）Java 中，直接缓冲区与非直接缓冲器有什么区别？ 
72）Java 中的内存映射缓存区是什么？ 
73）socket 选项 TCP NO DELAY 是指什么？ 
74）TCP 协议与 UDP 协议有什么区别？ 
75）Java 中，ByteBuffer 与 StringBuffer有什么区别？

## NIO 为什么性能这么高? 它解决什么问题

## 非阻塞 IO 的本质

## Linux 中 epool 和 select 区别, epoll 在 windwos 下支持吗

## Reactor 模式是什么, Pipeline 模式是什么

## 常用的网络协议

## TCP 和 UDP 的区别

* File

* File类型中定义了什么方法来判断一个文件是否存在

* File类型中定义了什么方法来创建一级目录

* 流

* 为了提高读写性能，可以采用什么流

* Java中有几种类型的流

* JDK 为每种类型的流提供了一些抽象类以供继承，分别是哪些类

* 对文本文件操作用什么I/O流

* 对各种基本数据类型和String类型的读写，采用什么流

* 能指定字符编码的 I/O 流类型是什么

* 序列化

* 什么是序列化？如何实现 Java 序列化及注意事项

* Serializable 与 Externalizable 的区别

* Socket

* socket 选项 TCP NO DELAY 是指什么

* Socket 工作在 TCP/IP 协议栈是哪一层

* TCP、UDP 区别及 Java 实现方式

* 说几点 IO 的最佳实践

* 直接缓冲区与非直接缓冲器有什么区别？

* 怎么读写 ByteBuffer？ByteBuffer 中的字节序是什么

* 当用System.in.read(buffer)从键盘输入一行n个字符后，存储在缓冲区buffer中的字节数是多少

* 如何使用扫描器类（Scanner Class）令牌化
